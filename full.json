{"version": "https://jsonfeed.org/version/1.1",
"title": "Пшерги кодинг",
"home_page_url": "https://eduard-sukharev.github.io/",
"feed_url": "https://eduard-sukharev.github.io/full.json",
"description": "Блог разработчика. Потому что правильные вещи нужно записывать.",
"user_comment": "Пшерги кодинг JSON feed (full articles)",
"authors": [
  {
    "name": "Эдуард Сухарев",
    "url": "https://eduard-sukharev.github.io/"
  }
],
"language": "ru",
"icon" : "https://eduard-sukharev.github.io/icon-192.png",
"favicon" : "https://eduard-sukharev.github.io/icon-512.png","items": [{"id": "https://eduard-sukharev.github.io/php-rector-i-kak-on-vam-ne-pomozhet/",
"url": "https://eduard-sukharev.github.io/php-rector-i-kak-on-vam-ne-pomozhet/",
"title": "PHP Rector и как он вам [не] поможет",
"date_published": "2023-10-23T00:00:00Z",
"language": "","content_html": "&lt;p&gt;Все, кто планировал переход на новые версии PHP слышали о проекте Rector для автоматизации рефакторинга и адаптации новых фич. Каждый кто завершал такой переход может рассказать пачку историй о том как и когда всё пошло не по плану.&lt;/p&gt;
&lt;h2 id=&quot;chto-takoe-rector&quot;&gt;Что такое Rector&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://getrector.com/&quot;&gt;Rector&lt;/a&gt; это инструмент автоматизации рефакторинга и апгрейда кодовой базы. Он поможет с базовыми вещами вроде добавления тайп-хинтов и конвертацией PhpDoc в аттрибуты. Более того, типичные сценарии объединены в наборы правил: например набор Php52 для миграции на PHP 5.2 содержит сразу два правила: ContinueToBreakInSwitchRector и VarToPublicPropertyRector, которые заменят &lt;code&gt;continue&lt;/code&gt; на &lt;code&gt;break&lt;/code&gt; в switch-конструкциях и заменят ключевое слово &lt;code&gt;var&lt;/code&gt; на &lt;code&gt;public&lt;/code&gt; в объявлении полей класса, соответственно. Удобно!&lt;/p&gt;
&lt;h2 id=&quot;v-chyom-podvoh&quot;&gt;В чём подвох?&lt;/h2&gt;
&lt;p&gt;Давайте рассмотрим типичный пример апгрейда PHP между мажорными версиями - ведь именно это опаснее всего и именно в таких случаях мы хотим подстелить соломку. К примеру, пусть мы хотим обновить наш страшный legacy проект с PHP 5.6 на PHP 7.0. Смотрим на несовместимые изменения в &lt;a href=&quot;https://www.php.net/manual/en/migration70.incompatible.php&quot;&gt;PHP 7.0&lt;/a&gt; и видим среди прочих:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Negative bitshifts теперь бросают эксепшен, однако в Rector нет правил на то, чтобы детектить такие случаи&lt;/li&gt;
&lt;li&gt;Удалены все ext/mysql и ext/mssql функции - Rector также не подсветит вам что вы их испльзуете&lt;/li&gt;
&lt;li&gt;Функции &lt;code&gt;set_socket_blocking&lt;/code&gt; и &lt;code&gt;set_magic_quotes_runtime&lt;/code&gt; (с алиасом &lt;code&gt;magic_quotes_runtime&lt;/code&gt;) удалены - не обнаруживается Rector&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;и др.&lt;/p&gt;
&lt;h2 id=&quot;chto-lishnego-v-rector&quot;&gt;Что лишнего в Rector?&lt;/h2&gt;
&lt;p&gt;В то же самое время в наборе правил Rector для Php70 есть следующие штуки:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Использование &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; вместо тернарных операторов&lt;/li&gt;
&lt;li&gt;Замена if/else и тернарных операторов на оператор &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Замена if+isset и тернарных операторов на &lt;code&gt;??&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Замена вложенных вызовов &lt;code&gt;dirname()&lt;/code&gt; на один с указанием глубины&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Хорошие правила, полезные, но не первой необходимости. Такие правки увеличивают и без этого потенциально крупное изменение в коде, усложняя процесс ревью. В целом отлично когда вы рутинно апгрейдитесь с одной версии пакета на другую или между минорными версиями языка.
Для случаев когда вы просто хотите чтобы при апгрейде ничего не сломалось, нужен более лаконичный набор правил.&lt;/p&gt;
&lt;h2 id=&quot;kakie-est-alternativy&quot;&gt;Какие есть альтернативы?&lt;/h2&gt;
&lt;p&gt;А в общем-то альтернативы не то чтобы есть. &lt;a href=&quot;https://packagist.org/packages/phpstan/phpstan&quot;&gt;phpstan&lt;/a&gt; и &lt;a href=&quot;https://packagist.org/packages/vimeo/psalm&quot;&gt;psalm&lt;/a&gt; могут помочь привести в порядок кодовую базу в соответствии с наборами правил, однако точно так же базовые наборы обычно слишком широки и вносят слишком много лишних изменений.&lt;/p&gt;
&lt;p&gt;Важный урок, который я вынес из общения с этими инструментами: эти инструменты не сделают волшебно, бесшовно и безболезненно.&lt;/p&gt;
&lt;p&gt;Некоторые автоматизированные правки могут прикрыть вам тыл, тогда как другие внесут ошибки &lt;a href=&quot;https://www.php.net/manual/ru/language.oop5.variance.php&quot;&gt;ковариантности и контравариантности&lt;/a&gt; в наследовании. Такие ошибки интерпретатор отловит при первой же попытке запустить проект, но что если ошибки могут проявиться только в райнтайме?
Например, добавленный &lt;code&gt;declare(strict_types=1);&lt;/code&gt; сделает ваш код более строгим и там где раньше срабатывало приведение типов, теперь появится ошибка!&lt;/p&gt;
&lt;h2 id=&quot;tak-chto-delat-to&quot;&gt;Так что делать-то?&lt;/h2&gt;
&lt;p&gt;В конечном итоге мы хотим без ошибок выкатить в продакшен код на новой версии языка.&lt;/p&gt;
&lt;p&gt;Это означает что мы хотим как можно больше ошибо найти на ранних стадиях перехода - чем раньше, тем лучше, тем дешевле. Так что самое очевидное - &lt;strong&gt;обложитесь тестами&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Если тестами обкладываться сложно, долго и дорого (потому что у вас legacy) - найдите ключевой функционал и покройте тестами хотя бы его. Вероятно чтобы покрыть его тестами вам будет нужно сначала вручную &lt;strong&gt;критические части кода хорошенько отрефакторить&lt;/strong&gt; и например уложить в классы с полноценным внедрением зависимостей, вынесением низкоуровневой работы с БД или сетью в отдельные классы, внедрением работы с интерфейсами и абстракцией вместо конкретных реализаций, и в целом обмазывании себя типизацией со всех сторон.&lt;/p&gt;
&lt;p&gt;И все проблемы автоматических инструментов сводятся к тому что они могут быть лишь настолько умными, насколько это возможно. Если ваша функция работы с БД принимает аргумент &lt;code&gt;$ref&lt;/code&gt; типа &lt;code&gt;int[]|string[]|false|null|mixed&lt;/code&gt;, то поможет вам только собственный опыт в том как этот клубок распутать и что делать дальше, потому что применение автоматизации здесь совершенно невозможно.&lt;/p&gt;
&lt;h2 id=&quot;v-zaklyuchenie&quot;&gt;В заключение&lt;/h2&gt;
&lt;p&gt;Может показаться что я утверждаю что такие инструменты как Rector, psalm и phpstan не нужны, однако это совершенно не так. Я лишь подсвечиваю тот момент, которому не всегда деляют много внимания в диферамбах о том, как быстро и легко обновить весь проект с егозависимостями.&lt;/p&gt;
&lt;p&gt;Будьте готовы к тому что инструменты сделают хуже или привнесут неочевидные ошибки, однако эти же инструменты помогут найти самые проблемные участки кода, за которые уже придётся взяться вручную.&lt;/p&gt;
&lt;p&gt;Успешного вам обновления.&lt;/p&gt;
"
    },{"id": "https://eduard-sukharev.github.io/obuyavlyajte-klassy-final-po-umolchaniyu/",
"url": "https://eduard-sukharev.github.io/obuyavlyajte-klassy-final-po-umolchaniyu/",
"title": "Объявляйте классы final по-умолчанию",
"date_published": "2023-07-26T00:00:00Z",
"language": "","content_html": "&lt;p&gt;Ключевое слово &lt;code&gt;final&lt;/code&gt; появилось в PHP вместе с понятием классов, однако зачастую им пренебрегают.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TL;DR: Всегда объявляйте класс как &lt;code&gt;final&lt;/code&gt;, если все его публичные методы являются реализацией интерфейсов класса.&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;princip-open-closed&quot;&gt;Принцип Open-closed&lt;/h2&gt;
&lt;p&gt;Вспомним принцип Open-Closed из аббревиатуры SOLID:&lt;/p&gt;
&lt;p&gt;Программные сущности (классы, модули, функции и т. п.) должны быть открыты для расширения, но закрыты для изменения&lt;/p&gt;
&lt;p&gt;Закрытость для изменения в этом контексте означает что когда ваш код предоставляет какой-то интерфейс, этот интерфейс не должен меняться. В конце концов API это контракт, это обещание совместимости, это ответственность. Это не означает что реализация не может меняться — как раз наоборот!&lt;/p&gt;
&lt;p&gt;Однако “открытость к расширению” не означает “открытость к наследованию”. Композиция, Стратегия, EventListener, обратные вызовы - всё это рабочие способы расширять поведение без использования наследования, которые чаще всего ещё и более предпочтительны. Часто наследование делает код только более сложным и менее гибким.&lt;/p&gt;
&lt;h2 id=&quot;nasledovanie-vs-interfejsy&quot;&gt;Наследование vs Интерфейсы&lt;/h2&gt;
&lt;p&gt;Если ваш класс изначально не подразумевает наследование, то стоит сразу объявить его &lt;code&gt;final&lt;/code&gt;. Но как понять что наследование не потребуется в дальнейшем?&lt;/p&gt;
&lt;p&gt;Исходя из принципа “программировать на уровне интерфейсов, а не реализаций” следует сразу принять что либо наш класс изначально пишется как конечная реализация набора интерейсов, либо представляет собой интерфейс с частичной реализацией логики, т.е. является абстрактным классом.&lt;/p&gt;
&lt;p&gt;Само определение абстрактного класса подразумевает что его будут наследовать, &lt;code&gt;final&lt;/code&gt; здесь точно неприменим.&lt;/p&gt;
&lt;p&gt;Класс, реализующий интерфейс же может иметь наследников, однако таковые либо полностью заново реализуют всё тот же интерфейс, а значит наследование здесь лишнее, либо общие элементы реализации просятся в абстрактный класс.&lt;/p&gt;
&lt;p&gt;Таким образом получается что если ваш класс реализует интерфейс, то вполне уместно сразу же объявить его &lt;code&gt;final&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;problemy-s-testirovaniem&quot;&gt;Проблемы с тестированием&lt;/h2&gt;
&lt;p&gt;Тестовые фреймворки полагаются на возможность наследования классов для создания моков и заглушек. Как с этим быть?&lt;/p&gt;
&lt;p&gt;Можно конечно вместо объявления класса как &lt;code&gt;final&lt;/code&gt; добавить ему аннотацию (или phpdoc) &lt;code&gt;@internal&lt;/code&gt; что пометит класс, как часть внутренней реализации и хотя технически его всё ещё можно будет наследовать, мы явно объявим о своей интенции и сделаем вид что всё хорошо.&lt;/p&gt;
&lt;p&gt;Но есть способ лучше - покрыть все публичные методы такого класса соответствующим набором интерфейсов. В таком случае наш код будет работать с абстракциями, в то время как тесты смогут сгенерировать на основе интерфейсов необходимые заглушки.&lt;/p&gt;
&lt;h2 id=&quot;pochemu-final-eto-horosho&quot;&gt;Почему &lt;code&gt;final&lt;/code&gt; это хорошо&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Предотвращает формирования адских цепочек наследования вида &lt;code&gt;MailDeliveryBot&lt;/code&gt; → &lt;code&gt;Bot&lt;/code&gt; → &lt;code&gt;Admin&lt;/code&gt; → &lt;code&gt;User&lt;/code&gt; → &lt;code&gt;Core&lt;/code&gt; → &lt;code&gt;Db&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Подталкивает к использованию композиции. Скорее всего вам не нужно наследование при работе с этим классом, если изначально он не планировался как абстрактный класс.&lt;/li&gt;
&lt;li&gt;Заставляет продумывать API библиотек и решений. Наследование нарушает инкапсуляцию. Если класс явно не создавался под наследование, то можно получить проблемы с совместимостью. Трижды думайте перед тем как использовать &lt;code&gt;extends&lt;/code&gt; и используйте &lt;code&gt;final&lt;/code&gt; чтобы не заставлять других ломать голову.&lt;/li&gt;
&lt;li&gt;Подталкивает к сужению публичного API классов&lt;/li&gt;
&lt;li&gt;При необходимости &lt;code&gt;final&lt;/code&gt; можно убрать, но придётся привести веские доводы и принять это решение явно&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;v-kakih-sluchayah-primenyat-final&quot;&gt;В каких случаях применять &lt;code&gt;final&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Классы объявленные как &lt;code&gt;final&lt;/code&gt; эффективно работают только в при соблюдении следующих условий:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Класс, объявленный &lt;code&gt;final&lt;/code&gt; реализует некоторый набор интерфейсов&lt;/li&gt;
&lt;li&gt;Все публичные методы класса покрыты этими интерфейсами&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Если хотя бы один из пунктов отсутствует, то это явный признак того, что ваш код не в полной мере полагается на абстракции, а значит рано или поздно вы можете прийти к решению через наследование. В таком случае лучше сделать шаг назад и, взглянув на холст вашего проекта целиком, придумать как решить проблему с помощью введения соответствующих абстракций.&lt;/p&gt;
&lt;h2 id=&quot;bonus&quot;&gt;Бонус&lt;/h2&gt;
&lt;p&gt;Шаблон для создания PHP классов в PhpStorm:&lt;/p&gt;
&lt;pre class=&quot;language-php&quot;&gt;&lt;code class=&quot;language-php&quot;&gt;&lt;span class=&quot;token php language-php&quot;&gt;&lt;span class=&quot;token delimiter important&quot;&gt;&amp;lt;?php&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;declare&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;strict_types&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;#if (${NAMESPACE})&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;token variable&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;NAMESPACE&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;#end&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token variable&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;NAME&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;

&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
"
    },{"id": "https://eduard-sukharev.github.io/izbegajte-otricatelnyh-uslovij/",
"url": "https://eduard-sukharev.github.io/izbegajte-otricatelnyh-uslovij/",
"title": "Избегайте отрицательных условий",
"date_published": "2023-07-19T00:00:00Z",
"language": "","content_html": "&lt;p&gt;Разберём на примерах известное правило избегания отрицаний в условиях. Какие бывают отрицания и чем они опасны.&lt;/p&gt;
&lt;p&gt;Начнём с первоисточника&lt;/p&gt;
&lt;h2 id=&quot;kak-u-dyadi-boba&quot;&gt;Как у Дяди Боба&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;G29: Избегайте отрицательных условий
Отрицательные условия немного сложнее для понимания, чем положительные. Таким образом, по возможности старайтесь формулировать положительные условия. Например запись&lt;/p&gt;
&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;buffer&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;shouldCompact&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;предпочтительнее записи&lt;/p&gt;
&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;buffer&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;shouldNotCompact&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;Заметим, что в такой формулировке и с таким примером не совсем ясно чего стоит избегать - логических операторов отрицания или отрицаний при именовании переменных и методов. Однако, кажется, можно сказать что стоит избегать двойного отрицания, как очевидно сложного для восприятия условия.&lt;/p&gt;
&lt;p&gt;Что ж, давайте разбираться.&lt;/p&gt;
&lt;h2 id=&quot;operatory-otricaniya&quot;&gt;Операторы отрицания&lt;/h2&gt;
&lt;p&gt;Рассмотрим синтетический пример метода проверки авторизации пользователя и соответствующий вариант его использования:&lt;/p&gt;
&lt;pre class=&quot;language-python&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;AnonymousAuthenticator&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;is_authenticated&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; request&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; Request&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;True&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;PublicController&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;index_action&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; request&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; Request&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    authenticator &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; AnonymousAuthenticator&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;not&lt;/span&gt; authenticator&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;is_authenticated&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;request&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;authentication required&quot;&lt;/span&gt;

    &lt;span class=&quot;token comment&quot;&gt;# ...&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;# do some business logic&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;# ...&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Successfuly authenticated&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Классический ход - если пользователь не авторизован, то сразу же вернём ответ. Если предположить что Роберт Мартин имел ввиду избегать операторы отрицания, то какие у нас есть варианты?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Переписать условие так, чтобы не было оператора отрицания. В таком случае основная бизнес логика ляжет внутрь &lt;code&gt;if is_authenticated&lt;/code&gt;, а негативный кейс уедет в самый конец, возможно, на пару экранов, где уже будет неясно какое условие там проверялось. Кроме того, весь код получит лишний уровень вложенности, что как известно негативно влияет на его восприятие.&lt;/li&gt;
&lt;li&gt;Добавить метод &lt;code&gt;is_not_authenticated&lt;/code&gt; в класс &lt;code&gt;AnonymousAuthenticator&lt;/code&gt;. В таком случае мы либо получим дублирование логики с методом &lt;code&gt;is_authenticated&lt;/code&gt;, которое приведёт к ошибкам в рассинхронизации двух вариантов реализации, либо отрицательное условие с вызовом &lt;code&gt;is_authenticated&lt;/code&gt; переместится внутрь этого метода. Да ещё и отрицание теперь будет в названии метода.&lt;/li&gt;
&lt;li&gt;Добавить метод &lt;code&gt;is_forbidden&lt;/code&gt; в класс &lt;code&gt;AnonymousAuthenticator&lt;/code&gt;. Проблемы те же что для предыдущего варианта, но имя уже как будто не содержит отрицания.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Все три варианта выглядят сомнительно и имеют свои недостатки, однако последний содержит нюанс, который я рекомендую избегать.&lt;/p&gt;
&lt;h2 id=&quot;otricaniya-v-yazyke&quot;&gt;Отрицания в языке&lt;/h2&gt;
&lt;p&gt;Если бы в естественных языках отрицание выражалось только частицами “не” и “нет”, то это были бы очень скудные по выразительности языки.&lt;/p&gt;
&lt;p&gt;Рассмотрим каким образом отрицания могут реализовываться в языках программаривания:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;not&lt;/code&gt; - отрицание с помощью частиц &lt;code&gt;no&lt;/code&gt; и &lt;code&gt;not&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;disable&lt;/code&gt;, &lt;code&gt;inactive&lt;/code&gt; - отрицание с помощью префиксов &lt;code&gt;in-&lt;/code&gt;, &lt;code&gt;un-&lt;/code&gt;, &lt;code&gt;dis-&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;powerOff&lt;/code&gt; - отрицание с помощью фразовых глаголов (комбинации глагола и предлога, образующие цельную смысловую единицу)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;forbid&lt;/code&gt;, &lt;code&gt;reject&lt;/code&gt; - слова с очевидным или неочевидным отрицанием в их смысловой нагрузке, но формально не попадающие под предыдущие категории&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Как ни странно, самый безобидный из этих вариантов - именно первый. Рассмотрим пример:&lt;/p&gt;
&lt;pre class=&quot;language-php&quot;&gt;&lt;code class=&quot;language-php&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name-definition class-name&quot;&gt;EditorAccessCheck&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;ENABLED&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string single-quoted-string&quot;&gt;&#39;enabled&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function-definition function&quot;&gt;isNotAllowed&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name type-declaration&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;token variable&quot;&gt;$user&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword return-type&quot;&gt;bool&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token variable&quot;&gt;$user&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;isEditor&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name-definition class-name&quot;&gt;NewsController&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function-definition function&quot;&gt;editAction&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name type-declaration&quot;&gt;Request&lt;/span&gt; &lt;span class=&quot;token variable&quot;&gt;$request&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name type-declaration&quot;&gt;EditorAccessCheck&lt;/span&gt; &lt;span class=&quot;token variable&quot;&gt;$accessCheck&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token class-name return-type&quot;&gt;Response&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token variable&quot;&gt;$accessCheck&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;isNotAllowed&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;AccessDeniedResponse&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Response&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string double-quoted-string&quot;&gt;&quot;Welcome to editor&#39;s club!&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Использованием метода читается довольно просто и понятно, несмотря на отриание в названии. Заметим что условие, которое проверяется внутри самого метода также содержит отрицание через оператор &lt;code&gt;!&lt;/code&gt;, однако и оно не мешает воспринимать код. Проблемы начнутся когда кто-нибудь решит воспользоваться &lt;code&gt;EditorAccessCheck&lt;/code&gt; в ином контексте:&lt;/p&gt;
&lt;pre class=&quot;language-php&quot;&gt;&lt;code class=&quot;language-php&quot;&gt;
&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name-definition class-name&quot;&gt;EditorActionSubscriber&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;EventSubscriber&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function-definition function&quot;&gt;__construct&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token class-name type-declaration&quot;&gt;EditorAccessCheck&lt;/span&gt; &lt;span class=&quot;token variable&quot;&gt;$accessCheck&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function-definition function&quot;&gt;supports&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword return-type&quot;&gt;bool&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token variable&quot;&gt;$this&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;&lt;span class=&quot;token property&quot;&gt;accessCheck&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;isNotAllowed&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function-definition function&quot;&gt;onEvent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name type-declaration&quot;&gt;UserActionEvent&lt;/span&gt; &lt;span class=&quot;token variable&quot;&gt;$event&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword return-type&quot;&gt;void&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// React to $event&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Здесь появляется проблема: &lt;strong&gt;двойное отрицание&lt;/strong&gt;. Как избавиться от двойного отрицания в условиях? Изменить условие так, чтобы можно было убрать одно из них. Вот только убрать таким образом можно лишь оператор отрицания, потому что для изменения названия метода придётся пройтись по всей кодовой базе и не просто изменить название вызываемого метода, но и изменить всю логику этих вызовов, чтобы сохранить работоспособность приложения.&lt;/p&gt;
&lt;h2 id=&quot;neyavnoe-dvojnoe-otricanie&quot;&gt;Неявное двойное отрицание&lt;/h2&gt;
&lt;p&gt;Все довольно просто когда мы смотрим на переменные с частицами &lt;code&gt;No&lt;/code&gt; и &lt;code&gt;Not&lt;/code&gt;, однако то же самое касается и вариантов с неявным отрицанием:&lt;/p&gt;
&lt;pre class=&quot;language-php&quot;&gt;&lt;code class=&quot;language-php&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token variable&quot;&gt;$disabled&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;call_when_enabled&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;или&lt;/p&gt;
&lt;pre class=&quot;language-python&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;not&lt;/span&gt; inactive&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
  call_when_active&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Оба варианта содержат двойное отрицание, которое сложно воспринимать, даже несмотря на то, что ни одна из переменных не имеет явного отрицания с частицами &lt;code&gt;not&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;vyvod&quot;&gt;Вывод&lt;/h2&gt;
&lt;p&gt;Сам по себе оператор отрицания не несёт в себе ничего плохого и не может рассматриваться как запах кода. Проблемы с пониманием кода возникают при двойном отрицании, которое можно легко исправить если отрицание не заложено — явно или неявно — в имена переменных и методов.&lt;/p&gt;
&lt;h2 id=&quot;some-shit&quot;&gt;Some shit&lt;/h2&gt;
&lt;p&gt;Рассмотрим примеры из реальных проектов. Например, отрицание проверки отрицательного флага&lt;/p&gt;
&lt;pre class=&quot;language-php&quot;&gt;&lt;code class=&quot;language-php&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token variable&quot;&gt;$widget&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;isFlagEnabled&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name static-context&quot;&gt;ProductFlag&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;DISABLED&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// do something&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Чтобы каждый раз не пытаться понять что имелось ввиду, можно инкапсулировать эту логику в метод с понятным названием:&lt;/p&gt;
&lt;pre class=&quot;language-php&quot;&gt;&lt;code class=&quot;language-php&quot;&gt;    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function-definition function&quot;&gt;isActive&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword return-type&quot;&gt;bool&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token variable&quot;&gt;$this&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;isFlagEnabled&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name static-context&quot;&gt;ProductFlag&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;DISABLED&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Хотя кажется правильней было бы ориентироваться на константу &lt;code&gt;ProductFlag::ENABLED&lt;/code&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Ещё один пример в коде, который пока нельзя назвать проблемой, но уже явно попахивает:&lt;/p&gt;
&lt;pre class=&quot;language-php&quot;&gt;&lt;code class=&quot;language-php&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name-definition class-name&quot;&gt;WidgetFlag&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;DISABLED&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0x0001&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function-definition function&quot;&gt;getList&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword return-type&quot;&gt;array&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
            &lt;span class=&quot;token keyword static-context&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;DISABLED&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token string single-quoted-string&quot;&gt;&#39;Выключено&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Что мы видим:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Константа с неявным отрицательным смыслом;&lt;/li&gt;
&lt;li&gt;Из значения &lt;code&gt;0x0001&lt;/code&gt; можно сделать предположение, что есть, вероятно среди возможных значений хранящихся в БД или приходящих по API, ещё неявная положительная константа &lt;code&gt;ACTIVE = 0x0000;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Иногда плохие примеры получаются из-за проблем самого языка. Например в некоторых языках различные типы могут неявно приводиться к булеву типу, причем с различными побочными эффектами. И бывает так что для борьбы с этим выбирают не самые удачные решения:&lt;/p&gt;
&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;isAdmin&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;admin&#39;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; user&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;user&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;admin &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;p&gt;Прилагательное вместо глагола inactive -&amp;gt; deactivate / setInactive:&lt;/p&gt;
&lt;pre class=&quot;language-php&quot;&gt;&lt;code class=&quot;language-php&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function-definition function&quot;&gt;inactive&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword return-type&quot;&gt;void&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token variable&quot;&gt;$this&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;&lt;span class=&quot;token property&quot;&gt;isActive&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token constant boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;vmesto-zaklyucheniya&quot;&gt;Вместо заключения&lt;/h2&gt;
&lt;pre class=&quot;language-html&quot;&gt;&lt;code class=&quot;language-html&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;input&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;checkbox&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;disabled&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;disabled&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Мы вероятно уже привыкли и это уже не исправить, но это отвратительно: двойное отрицание которое всё же отрицание&lt;/p&gt;
"
    }]
}